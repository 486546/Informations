# 搜索+模拟
这节课会是一个超级恶心的课。\
先来说说搜索

## 搜索
搜索有很多，包括  `dfs`、`bfs`、`A*`等等。

---

先来看看 `dfs` 。\
适用范围很广，包括全排列、枚举子集、树的遍历、图的遍历……\
枚举自己可以用位运算来算，看大家位运算功底了。\
如果用位运算来做，那么就会快不少。\
比如我们枚举一个 $1...S$ 的子集。
```cpp
for (int i = S; i; i = (i - 1) & S)
```

---

再来看看 `bfs` ，一般可以用来求最短距离、最少步数等等。\
这是我们就要延伸出一个迭代加深搜索。\
也就是既兼顾空间又要求出最小的距离/步数。\
比如 `bfs` 的速度快，但是如果遇到一种可怕的二叉树，如满二叉树，那么这个时候空间就会炸。\
`dfs` 不一样，他速度慢，但是空间绝对很好。\
那么能不能结合一下 `dfs` 和 `bfs` 呢？\
这就是迭代加深搜索。\
本质上就是下定深度的 `dfs` 。\
若超过限定步数就返回。\
若搜不到解就继续搜索，直到找到一组解。

---

启发式搜索 `A*` 。\
使用估价函数优化 `bfs` 。\
当前步数+估价越小，则越有潜力。\
使用优先队列存储带搜索状态，每次取最有潜力的进行搜索。\
假设起点是 $s$ ，有一个阶段 $S$ ，之间的距离是 $w$ ，那么我们可以取曼哈顿距离为估价函数来看是否有必要继续走下去。\

---

来看个例题。\
题目有点吓人：\
给定一个 $N$ 行 $M$ 列的 $01$ 矩阵 $A[i][j]$ ，我们定义曼哈顿距离：

$$
dist(A[i][j], A[k][l]) = |i-k|+|j-l|
$$

请输出一个 $B$ 。

$$
B[x][y]=\min\limits_{1\leq i \leq n, 1 \leq j \leq m,A[i][j]=1} dist(A[i][j], A[x][y]) 
$$

但实质就是个多源最短路径，我们虚构一个起点，链接这些1，这样我们就可以从虚构起点开始 `bfs` 就做完了。
